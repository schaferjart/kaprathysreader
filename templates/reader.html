<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <style>
        /* Layout */
        body { margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; font-family: "Georgia", serif; background: #fff; }

        /* Sidebar */
        #sidebar { width: 300px; background: #f8f9fa; border-right: 1px solid #e9ecef; overflow-y: auto; padding: 20px; flex-shrink: 0; }
        .nav-header { font-family: -apple-system, sans-serif; font-weight: bold; color: #495057; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #dee2e6; }
        .nav-home { display: block; margin-bottom: 20px; color: #3498db; text-decoration: none; font-family: -apple-system, sans-serif; font-size: 0.9em; }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }
        ul.toc-list ul { padding-left: 20px; } /* Indent children */
        li.toc-item { margin-bottom: 8px; }
        a.toc-link { text-decoration: none; color: #495057; font-size: 0.95em; display: block; padding: 4px 0; line-height: 1.4; }
        a.toc-link:hover { color: #000; text-decoration: underline; }
        a.toc-link.active { color: #d63384; font-weight: bold; }

        /* Main Content */
        #main { flex-grow: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; }
        .content-container { max-width: 700px; margin: 0 auto; padding: 60px 40px; line-height: 1.8; font-size: 1.15em; color: #212529; }

        /* Content Styling (Basic normalization for the book HTML) */
        .book-content img { max-width: 100%; height: auto; display: block; margin: 20px auto; }
        .book-content h1, .book-content h2, .book-content h3 { font-family: -apple-system, sans-serif; margin-top: 1.5em; color: #333; }
        .book-content p { margin-bottom: 1.5em; text-align: justify; }

        /* Navigation Footer */
        .chapter-nav { display: flex; justify-content: space-between; margin-top: 60px; padding-top: 20px; border-top: 1px solid #eee; font-family: -apple-system, sans-serif; }
        .nav-btn { text-decoration: none; color: #3498db; font-weight: bold; padding: 10px 20px; border: 1px solid #3498db; border-radius: 4px; transition: all 0.2s; }
        .nav-btn:hover { background: #3498db; color: white; }
        .nav-btn.disabled { opacity: 0.5; pointer-events: none; border-color: #ccc; color: #ccc; }

        /* Chat Toggle Button */
        #chat-toggle { position: fixed; right: 20px; bottom: 20px; z-index: 100; background: #6c5ce7; color: white; border: none; border-radius: 50%; width: 50px; height: 50px; font-size: 1.4em; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
        #chat-toggle:hover { background: #5a4bd1; }

        /* Chat Panel */
        #chat-panel { width: 380px; flex-shrink: 0; border-left: 1px solid #e9ecef; display: none; flex-direction: column; background: #f8f9fa; font-family: -apple-system, sans-serif; }
        #chat-panel.open { display: flex; }
        #chat-header { padding: 12px 16px; border-bottom: 1px solid #e9ecef; display: flex; justify-content: space-between; align-items: center; font-weight: bold; color: #495057; }
        #chat-header button { background: none; border: 1px solid #ccc; border-radius: 4px; padding: 4px 10px; cursor: pointer; font-size: 0.8em; color: #666; }
        #chat-header button:hover { background: #eee; }
        #chat-messages { flex: 1; overflow-y: auto; padding: 16px; display: flex; flex-direction: column; gap: 10px; }
        .chat-bubble { max-width: 85%; padding: 10px 14px; border-radius: 12px; font-size: 0.9em; line-height: 1.5; word-wrap: break-word; }
        .chat-bubble.user { align-self: flex-end; background: #6c5ce7; color: white; border-bottom-right-radius: 4px; }
        .chat-bubble.assistant { align-self: flex-start; background: #e9ecef; color: #212529; border-bottom-left-radius: 4px; }
        .chat-bubble.error { align-self: center; background: #fee; color: #c00; font-size: 0.85em; }
        #chat-input-area { padding: 12px; border-top: 1px solid #e9ecef; display: flex; gap: 8px; }
        #chat-input { flex: 1; padding: 8px 12px; border: 1px solid #ccc; border-radius: 8px; font-size: 0.9em; outline: none; }
        #chat-input:focus { border-color: #6c5ce7; }
        #chat-send { background: #6c5ce7; color: white; border: none; border-radius: 8px; padding: 8px 16px; cursor: pointer; font-size: 0.9em; }
        #chat-send:hover { background: #5a4bd1; }
        #chat-send:disabled { opacity: 0.5; cursor: not-allowed; }
        .typing-indicator { align-self: flex-start; color: #999; font-style: italic; font-size: 0.85em; padding: 4px 0; }

    </style>
</head>
<body>

    <!-- SIDEBAR -->
    <div id="sidebar">
        <a href="/" class="nav-home">‚Üê Back to Library</a>
        <div class="nav-header">{{ book.metadata.title }}</div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    <!--
                        Matching Logic:
                        If the TOC item filename matches the current chapter filename, mark active.
                        Ideally we match spine indices, but Reader 3 TOC maps to filenames.
                        We use a simple hash matching logic here.
                    -->
                    {% set is_active = current_chapter.href == item.file_href %}

                    <!--
                       We need to find which linear chapter index (0, 1, 2) corresponds
                       to this TOC entry file.
                       Since that's hard to calculate in Jinja, we just link to the
                       file anchor. BUT, to make our linear navigation work, we
                       rely on the fact that the user is currently reading 'chapter_index'.

                       Ideally, clicking a TOC link should find the 'index' of that file.
                       For simplicity in this version: We link to the 'href' (filename)
                       and let JavaScript or Backend handle it?

                       Actually, let's just link to the file. The browser interprets #anchors.
                       However, our router uses /read/book/INDEX.

                       SIMPLE FIX: We won't link the TOC to the route index in this simple version
                       unless we build a map. We will visually show structure,
                       but rely on "Previous/Next" for linear reading.

                       BETTER FIX: Use JavaScript to match filenames.
                    -->
                    <a href="#" onclick="findAndGo('{{ item.file_href }}')"
                       class="toc-link {% if is_active %}active{% endif %}">
                        {{ item.title }}
                    </a>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <div id="main">
        <div class="content-container">
            <div class="book-content">
                {{ current_chapter.content | safe }}
            </div>

            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn">‚Üê Previous</a>
                {% else %}
                    <span class="nav-btn disabled">‚Üê Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ next_idx }}" class="nav-btn">Next ‚Üí</a>
                {% else %}
                    <span class="nav-btn disabled">Next ‚Üí</span>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- CHAT PANEL -->
    <div id="chat-panel">
        <div id="chat-header">
            <span>Reading Companion</span>
            <div>
                <button onclick="resetChat()">Reset</button>
                <button onclick="toggleChat()">Close</button>
            </div>
        </div>
        <div id="chat-messages"></div>
        <div id="chat-input-area">
            <input type="text" id="chat-input" placeholder="Ask about this chapter..." onkeydown="if(event.key==='Enter')sendMessage()">
            <button id="chat-send" onclick="sendMessage()">Send</button>
        </div>
    </div>

    <button id="chat-toggle" onclick="toggleChat()" title="Reading Companion">üí¨</button>

    <script>
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ ch.order }},
            {% endfor %}
        };

        function findAndGo(filename) {
            const cleanFile = filename.split('#')[0];
            const idx = spineMap[cleanFile];
            if (idx !== undefined) {
                window.location.href = "/read/{{ book_id }}/" + idx;
            } else {
                console.log("Could not find index for", filename);
            }
        }

        // Chat logic
        const bookId = "{{ book_id }}";
        const chapterIndex = {{ chapter_index }};
        const chatUrl = `/chat/${bookId}/${chapterIndex}`;
        const messagesEl = document.getElementById('chat-messages');
        const inputEl = document.getElementById('chat-input');
        const sendBtn = document.getElementById('chat-send');
        const panel = document.getElementById('chat-panel');
        let chatOpened = false;

        function toggleChat() {
            panel.classList.toggle('open');
            if (panel.classList.contains('open') && !chatOpened) {
                chatOpened = true;
                sendToServer("I just finished reading this section. What should I think about?");
            }
            if (panel.classList.contains('open')) {
                inputEl.focus();
            }
        }

        function addBubble(text, role) {
            const div = document.createElement('div');
            div.className = `chat-bubble ${role}`;
            div.textContent = text;
            messagesEl.appendChild(div);
            messagesEl.scrollTop = messagesEl.scrollHeight;
            return div;
        }

        function showTyping() {
            const div = document.createElement('div');
            div.className = 'typing-indicator';
            div.textContent = 'Thinking...';
            div.id = 'typing';
            messagesEl.appendChild(div);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function hideTyping() {
            const el = document.getElementById('typing');
            if (el) el.remove();
        }

        async function sendToServer(text) {
            addBubble(text, 'user');
            sendBtn.disabled = true;
            showTyping();
            try {
                const res = await fetch(chatUrl, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({message: text})
                });
                hideTyping();
                if (!res.ok) throw new Error(`Server error ${res.status}`);
                const data = await res.json();
                addBubble(data.reply, 'assistant');
            } catch (e) {
                hideTyping();
                addBubble(`Error: ${e.message}`, 'error');
            }
            sendBtn.disabled = false;
            inputEl.focus();
        }

        function sendMessage() {
            const text = inputEl.value.trim();
            if (!text) return;
            inputEl.value = '';
            sendToServer(text);
        }

        async function resetChat() {
            await fetch(chatUrl + '/reset', {method: 'POST'});
            messagesEl.innerHTML = '';
            chatOpened = false;
        }
    </script>
</body>
</html>
